---
title: "Simulation SimRevisionR2"
author: "Yenny Webb-Vargas"
date: "Wednesday, September 17, 2014"
output: html_document
---

This implements simulation for testing my functional mediation function. 

Load the library 'refund'. It also loads the library 'fda' among many others.
```{r}
library(refund)
```

Load the canonical HRF function
```{r}
short_HRF <- read.table("C:/Users/Yenny/Documents/GitHub/functional_mediation/YennyHRF")
plot(1:length(short_HRF), short_HRF, type="l")
```

```{r}
Z = c(rep(0,20), short_HRF, rep(0,20))

sub=20
nbasis = 30
norder = 6


set.seed(794320)
X = rep(0,sub)
X[sample(1:sub)[1:(floor(sub/2))]] = 2
X = X - 1 

M = sapply(1:sub, function(i) rnorm(n = length(Z),mean=0, sd=1))
Y = X + rnorm(sub, mean=0, sd=1)

# To test function
 x = X; y = Y; m=M;pen=0.1;estimate=2; lambda=10
check = fMediation_ML(X,Y,M,nbasis,norder)
```


```{r fMediation}
fMediation_ML <- function(x,y,m,nbasis,norder, pen=0.1, estimate=2, lambda=10){
require(fda)
len   = dim(m)[1]
N     = dim(m)[2]
T_sup = 1
  
timevec = seq(0,T_sup, length.out=len)
  
# Create bspline basis set
basis = create.bspline.basis(rangeval = c(0,T_sup), nbasis = nbasis, norder)

######################
#### Path x -> m #####
######################

# Convert time series data to functional data
mfd    = Data2fd(y = m,basisobj = basis,argvals = timevec)
mfdPar = fdPar(mfd)

# Create Design Matrix
conbas = create.constant.basis(c(0,T_sup))
confd  = fd(matrix(1,nrow=1,ncol=N), conbas)

xfdcell      = list()
xfdcell[[1]] = confd 
xfdcell[[2]] = x

# Create basis set for beta functions
betacell      = list()
betabasis     = create.bspline.basis(c(0,T_sup), nbasis, norder)
betafd1       = fd(1,conbas)
betacell[[1]] = fdPar(betafd1)
betafdj       = fd(matrix(0,nrow=nbasis, ncol=1), betabasis)
betacell[[2]] =fdPar(betafdj)

# Solve least-squares equation
fRegressCell = fRegress(mfdPar, xfdcell, betacell)
betaestcell  = fRegressCell[[4]]
afun         = betaestcell[[2]]$fd

tfine = seq(0,T_sup, length.out=len)
af    = eval.fd(tfine,afun)
a     = sum(af)*(tfine[2] - tfine[1])

ResM  = (m - eval.fd(tfine, fRegressCell[[5]]$fd))

# Calculate Standard Error
errmat     = m - eval.fd(tfine, fRegressCell[[5]]$fd)
Sigma      = errmat%*%t(errmat)/N  # Originally, there was a 20 here, I assume it is the number of observations N
DfdPar     = fdPar(basis, 0, 1)
y2cMap     = smooth.basis(timevec,m,DfdPar)$y2cMap
stderrCell = fRegress.stderr(fRegressCell, y2cMap, Sigma)
tmp        = stderrCell[[1]]

a_stderr = eval.fd(tfine, tmp[[2]]) # Std Error of a-function


######################
## Path x, m -> y  ###
######################

# Create Design matrix
mfdcell      = list()
mfdcell[[1]] = confd
basis        = create.bspline.basis(c(0,T_sup), nbasis, norder)
mfdcell[[2]] = Data2fd(argvals = timevec, y = m, basis)
mfdcell[[3]] = fd(matrix(x,nrow=1,ncol=N),conbas)
 
# Response variable
yfdPar = y

# Create basis set for beta functions
betacell      = list()
betafd1       = fd(1,conbas)
betacell[[1]] = fdPar(betafd1)
betafdj       = fd(rep(0,nbasis), basis)
betafdPar     = fdPar(betafdj, estimate, lambda)
betacell[[2]] = betafdPar
betacell[[3]] = fdPar(betafd1)

# Solve least-squares equation
fRegressCell = fRegress(yfdPar, mfdcell, betacell)
betaestcell  = fRegressCell[[4]]
bfun         = betaestcell[[2]]$fd

# Calculate Standard Error
errmat     = y - fRegressCell[[5]]
ResY       = errmat
Sigma      = errmat%*%t(errmat)/N  # Originally, there was a 20 here, I assume it is the number of observations N
DfdPar     = fdPar(basis, 0, 1)
y2cMap     = smooth.basis(timevec,m,DfdPar)$y2cMap
stderrCell = fRegress.stderr(fRegressCell, y2cMap, Sigma)
tmp        = stderrCell[[1]]

b_stderr = eval.fd(tfine, tmp[[2]]) # Std Error of b-function



bf = eval.fd(tfine,bfun)            # Evaluate b-function  
b  = sum(bf)*(tfine[2]-tfine[1])    # Integral of b-function: b = \int bf(t) dt gives b-path

abf = eval.fd(tfine,afun*bfun)      # ab-functions
ab  = sum(abf)*(tfine[2]-tfine[1])  # Integral of ab-function: ab = \int af(t)bf(t) dt gives ab-path

tmp = eval.fd(tfine, betaestcell[[3]]$fd) # c'-path
cp  = tmp[1]


######################
###  Path x -> y   ###
######################

# Create Design matrix
xfdcell      = list()
conbas       = create.constant.basis(c(0,T_sup))
confd        = fd(matrix(1,nrow=1,ncol=N), conbas)
xfdcell[[1]] = confd
xfdcell[[2]] = fd(matrix(x,nrow=1,ncol=N), conbas)

# Response variable
yfdPar = y

# Create basis set for beta functions
betacell      = list()
betafd1       = fd(1,conbas)
betacell[[1]] = fdPar(betafd1)
betacell[[2]] = fdPar(betafd1)

# Solve least-squares equation
fRegressCell = fRegress(yfdPar, xfdcell, betacell)
betaestcell  = fRegressCell[[4]]

tmp = eval.fd(tfine, betaestcell[[2]]$fd)
c   = tmp[1]

# Instrumental variables estimator
IV2 = c/af
  
A  = matrix(af, ncol=len, nrow=len, byrow = TRUE)
IV = solve(crossprod(A) + pen*diag(len))%*%t(A)%*%rep(1, len)
 
# Plot results
par(mfrow=c(3,1))
plot(tfine, eval.fd(tfine,afun), type="l", main="'a' function")
lines(tfine, af + 2*a_stderr, col="green")
lines(tfine, af - 2*a_stderr, col="green")

plot(tfine, eval.fd(tfine,bfun), type="l", main="'b' function")
lines(tfine, bf + 2*b_stderr, col="green")
lines(tfine, bf - 2*b_stderr, col="green")

plot(tfine, abf, type="l", main="'ab' function")

#plot(x,y)

result = list('afunction' = af, 'a' = a, 'bfunction' = bf, 'abfunction' = abf, 'b' = b, 'ab' = ab, 'c' = c, 'cp' = c,'x' = x, 'y' = y, 'm' = m,'tfine' = tfine,'b_stderr' = b_stderr,'IV' = IV,'IV2' = IV2,'ResM'= ResM,'ResY'= ResY)

return(result)
}
```

